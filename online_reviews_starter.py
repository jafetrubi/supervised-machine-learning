import pymongo as pym
import scipy
import statistics
from scipy import stats
import re
from bson.objectid import ObjectId

# Business Scenario:
# You have been hired by a local eCommerce company to analyze online reviews.
# In this review system, customers have the ability to leave a rating (1-5 stars) along
# with text based comments about their experience. You want to determine if customers
# who post positive reviews post them faster than customers who post negative reviews.
# You also want to determine if the sentiment expressed in the text comments is correlated with
# the star rating that they posted. You have been given two json files containing your data.
#
# The Reviews.json file contains the following fields:
# Author, which contains the name of the customer who left the online review.
# Comments, which contains the text-based comments left by the customer.
# ReviewDate, which contains the date (stored as a string) the review was posted online.
# Product Code, which contains the code for the product that was reviewed.
# Product Name, which contains the name of the product that was reviewed.
# Sentiment, which contains the negative, neutral, or positive sentiment that corresponds to the star rating.
# This field is generated by the system automatically and may or may not be correlated with their text-based comments.
# Usefulness, which contains the usefulness of the review (i.e, how many customers found the review useful).
# Rating, which contains the rating that customer left.
# PurchaseDate, which contains the date (stored as a string) when the customer made their purchase.
#
# The Words.json file contains the following fields:
# negative, which contains words that have negative sentiment.
# positive, which contains words that have positive sentiment.
#
# You decide to create a MongoDB to store your data that are contained in these two json files
# before you perform the appropriate analyses.

# Q1
# Load the data contained in the Reviews.json and Words.json files
# into a MongoDB database on the localhost using mongoimport.
# Name your MongoDB database sentiment.
# Name your collections Reviews for the documents contained in Reviews.json
# and Words for the documents contained in Words.json.

# mongoimport --db sentiment --collection Words --jsonArray --file Words.json --mode insert
# mongoimport --db sentiment --collection Reviews --jsonArray --file Reviews.json --mode insert

# Q2
# Build a fruitful function to establish a connection to your Mongo database.
# If the function successfully establishes a connection to the Mongo database,
# then it should return the client connection.
# If the function fails to establish a connection, then it should return a NoneType.
# The function should be named dtb_connection and should accept two arguments.
# The first argument stored in a parameter named ip contains the ip address
# of the server. The second argument stored in a parameter named port contains
# the port needed to establish the connection. This parameter should set the default
# to 27017 so the calling statement does not have to pass this argument to the function.

import pymongo as pym

def dtb_connection(ip, port=27017):
    """This fruitful function takes two arguments stored in the
    ip parameter variable and the port parameter variable.
    If we are connecting to a remote server, the value contained in the ip
    parameter variable would be something like 172.28.8.65. If we are connecting to
    mongo on your local machine, the value contained in the ip parameter would
    be localhost or 127.0.0.1 to signify that you are connecting to Mongo on
    your local machine. The port parameter variable is the port that you will use
    to connect  your Mongo server. It has a default value of 27017.

    If the function successfully establishes a connection to the Mongo database,
    then it will return the client connection.
    If the function fails to establish a connection, then it will return a
    NoneType"""
    try:
        client = pym.MongoClient(ip, port)
        client.server_info()
        return client
    except pym.errors.ServerSelectionTimeoutError:
        print('Connection Failed')
        return None

# Q3
# Call the function you created in the previous question to connect to your localhost.
# If the function returns a valid connection, then create variables for the
# database (sentiment) and both collections (Reviews and Words).
# If the function returns a NoneType (i.e., unsuccessful connection attempt), then
# display an informative error message.

dtb_connection('127.0.0.1')

client = pym.MongoClient('localhost',27017)
db = client['sentiment']
r_coll = db['Reviews']
w_coll = db['Words']

# Q4
# Change the data type of both variables that contain dates but that are
# stored as strings in each of the documents in the Reviews collection
# (ReviewDate and PurchaseDate).
# Note: We want these stored as ISODate data types instead of strings in the
# documents contained in the Reviews collection to make calculating the difference
# between these two dates easier.
import datetime
from bson.objectid import ObjectId

#just to double check to make sure we converted the data type correctly:
for reviews in r_coll.find():
    review_date = reviews.get("ReviewDate")
    print(review_date)
    print(type(review_date))

for reviews in r_coll.find():
    review_id = reviews.get("_id")
    print(review_id)
    if isinstance(reviews.get("ReviewDate"), str):
        my_date = datetime.datetime.strptime(reviews.get("ReviewDate"), "%m/%d/%Y")
        r_coll.update_one({"_id": ObjectId(review_id)}, {"$set": {"ReviewDate": my_date}})
    if isinstance(reviews.get("PurchaseDate"), str):
        my_date = datetime.datetime.strptime(reviews.get("PurchaseDate"), "%m/%d/%Y")
        r_coll.update_one({"_id": ObjectId(review_id)}, {"$set": {"PurchaseDate": my_date}})

# Q5
# Add a field named "time_btw_purchase_review" to each document in the Reviews
# collection. The values should be the number of days between the ReviewDate
# and the PurchaseDate.

for reviews in r_coll.find():
    review_id = reviews.get("_id")
    review_date = reviews.get("ReviewDate")
    print(f'\nReview date: {review_date}')
    purchase_date = reviews.get("PurchaseDate")
    print(f'Purchase date: {purchase_date}')
    time_btw_purchase_review = (review_date - purchase_date).days
    print(f'Days between purchase and review: {time_btw_purchase_review}')
    r_coll.update_one({"_id": ObjectId(review_id)}, {"$set": {"time_btw_purchase_review": time_btw_purchase_review}})

# Q6
# Determine if there is a correlation between the rating and the length of time
# it took to the customer to leave a review.
# The general idea is that customers may be more likely to leave a negative rating
# (low review on the five star rating system) faster than customers who leave a positive rating
# (high review on the five star rating system).
# After you calculate the correlation, print a statement such as the following:
# There was a 0.5 correlation between length of time to post a review and the rating scores, which had a p-value of 0.0.

import pymongo as pym
import scipy
import statistics
from scipy import stats
import re
from bson.objectid import ObjectId

for reviews in r_coll.find():
    review_id = reviews.get("_id")
    review_rating = ( (int(reviews.get("Rating")[0])) / 5)
    #print(review_rating)
    r_coll.update_one({"_id": ObjectId(review_id)}, {"$set": {"Ratings1": review_rating}})

days = []
rating = []
for reviews in r_coll.find():
    days.append(reviews.get("time_btw_purchase_review"))
    rating.append(reviews.get("Ratings1"))

correlation = stats.pearsonr(days, rating)
print(f'There was a {correlation[0]:,.1f} correlation between length of time to post a review and the rating scores, which had a p-value of {correlation[1]:,.1f}.')

# Q7
# Count the negative and positive words in the actual comments associated with each review.
# The comments are contained in the "Comments" field in each document in the Reviews collection.
# The negative words are contained in the negative field in each document in the Words collection.
# The positive words are contained in the positive field in each document in the Words collection.
# Add a field in the reviews collection for the number of times negative words appear in the "Comments"
# in each review. Name this field "num_negative_words".
# Add a field in the reviews collection for the number of times positive words appear in the "Comments"
# in each review. Name this field "num_positive_words".
client = pym.MongoClient('localhost',27017)
db = client['sentiment']
r_coll = db['Reviews']
w_coll = db['Words']
# Let's first create lists for the negative words and positive words.
pos_words = []
neg_words = []

for words in w_coll.find():
    if words.get("positive") != None:
        pos_words.append(words.get("positive"))
    elif words.get("negative") != None:
        neg_words.append(words.get("negative"))

pos_words = '|'.join(pos_words)
neg_words = '|'.join(neg_words)
print(pos_words)
print(neg_words)


# Now, let's loop over all of the documents in the reviews collection.
# For each document, let's use re.findall() to find all instances of each positive or negative word.
# The findall function returns a list so we can determine the number of instances of a word by
# extracting the length of the returned list. We can then create a cumulative count for each word in the
# list of negative words and each word in the list of positive words.

for reviews in r_coll.find():
    review_id = reviews.get("_id")
    my_comments = reviews.get("Comments")
    pos_len = len(re.findall(pos_words,my_comments))
    neg_len = len(re.findall(neg_words,my_comments))
    r_coll.update_one({"_id": ObjectId(review_id)}, {"$set": {"num_negative_words": neg_len}})
    r_coll.update_one({"_id": ObjectId(review_id)}, {"$set": {"num_positive_words": pos_len}})


# Q8
# Using the two count fields you added to each document in the Reviews collection in the last question,
# let's now calculate a numerical sentiment score for each review.
# The formula for this analysis is as follows:
# -1 * num_negative_reviews + 1 * num_positive_reviews
# Store each of these values in a field named sentiment_score in each document in the Reviews collection.
# While doing this calculation, let's also extract the numerical rating from the Ratings string field in the
# Reviews collection and store the number in a new field named ratings_num in each document in the Reviews collection.
# Finally, determine if there is a correlation between the rating and the calculated sentiment score.
# Print a message similar to the following:
# There was a 0.32 correlation between calculated sentiment and the rating scores, which had a p-value of 0.0.

for reviews in r_coll.find():
    review_id = reviews.get("_id")
    num_negative_reviews = int(reviews.get("num_negative_words"))
    num_positive_reviews = int(reviews.get("num_positive_words"))
    num_sentiment = (-1 * num_negative_reviews + 1 * num_positive_reviews)
    r_coll.update_one({"_id": ObjectId(review_id)}, {"$set": {"sentiment_score": num_sentiment}})
    review_rating = ((int(reviews.get("Rating")[0])))
    r_coll.update_one({"_id": ObjectId(review_id)}, {"$set": {"ratings_num": review_rating}})

sentiment_score = []
ratings_num = []
for reviews in r_coll.find():
    sentiment_score.append(reviews.get("sentiment_score"))
    ratings_num.append(reviews.get("ratings_num"))

corr = stats.pearsonr(sentiment_score, ratings_num)
print(f'There was a {corr[0]:,.2f} correlation between calculated sentiment and the rating scores, which had a p-value of {corr[1]:,.2f}.')

# Q9
# Calculate the percent usefulness of reviews based on the string that is contained in the "Usefulness"
# field in the documents in the Reviews collection. Note that not all documents in the Reviews collection
# have this "Usefulness" field. A sample value in this field could be the following:
# "1 of 2 people found the following review helpful"
# For this document, you would calculate the percentage as (1 / 2) * 100
# After you calculate it, store the value in a field named "percent_useful" in each document
# that contains the Usefulness field in the Reviews collection.

for reviews in r_coll.find():
    usefulness = reviews.get("Usefulness")
    review_id = reviews.get("_id")
    if usefulness != None:
        usefulness_num = (usefulness[0:3].strip())
        usefulness_denom = (usefulness[5:10].strip())
        usefulness_num = int(re.sub('[a-zA-Z]', '', str(usefulness_num)).strip())
        usefulness_denom = int(re.sub('[a-zA-Z]', '', str(usefulness_denom)).strip())
        percent_useful = (usefulness_num / usefulness_denom) * 100
        r_coll.update_one({"_id": ObjectId(review_id)}, {"$set": {"percent_useful": percent_useful}})
    elif usefulness == None:
        continue

# to check if it did work
for reviews in r_coll.find():
    print(reviews.get("Usefulness"))
    print(reviews.get("percent_useful"))

# Q10
# For the documents contained in the Reviews collection that have a percent_useful field,
# output the following statements to a new Excel document. The first statement should
# go in cell A1, the second statement in cell A2, and so on. Name the Excel document
# "online_reviews.xlsx" and name the worksheet containing the data "Results".
# The sentiment is derived from the sentiment_score field in the documents contained in the Reviews collection
# for all documents grouped based on the ratings_num.
# The usefuleness is derived from the percent_useful field in the documents contained in the Reviews collection
# for all documents grouped based on the ratings_num.

# 1 Stars: The avg sentiment was -1.62 with a stdev of 3.31 and their avg usefulness was 85.38 with a stdev of 26.57.
# 2 Stars: The avg sentiment was -1.4 with a stdev of 3.02 and their avg usefulness was 90.0 with a stdev of 28.03.
# 3 Stars: The avg sentiment was -0.04 with a stdev of 3.02 and their avg usefulness was 70.14 with a stdev of 36.72.
# 4 Stars: The avg sentiment was 0.39 with a stdev of 3.84 and their avg usefulness was 81.03 with a stdev of 31.72.
# 5 Stars: The avg sentiment was 1.71 with a stdev of 3.02 and their avg usefulness was 78.67 with a stdev of 28.48.

# For this question, you MUST use an aggregation query from your Reviews collection.
# You can use the $stdDevSamp operator to calculate the standard deviations in your aggregation query.
